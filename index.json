[{"categories":["Programming Language"],"contents":"MVN ON WSL 如果透過apt install maven會裝到ubuntu版的maven而不是apache版的maven 參考 如果下mvn -v出現下列output\nmvn --version Apache Maven 3.6.3 Maven home: /usr/share/maven Java version: 1.7.0_80, vendor: Oracle Corporation, runtime: /home/jqno/.jabba/jdk/1.7.80-oracle/jre Default locale: en_US, platform encoding: UTF-8 OS name: \u0026#34;linux\u0026#34;, version: \u0026#34;5.11.0-16-generic\u0026#34;, arch: \u0026#34;amd64\u0026#34;, family: \u0026#34;unix\u0026#34; 表示不是用apache maven\n以下output才是apache maven\nApache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f) Maven home: /Users/XXX/tools/maven Java version: 1.7.0_302, vendor: Azul Systems, Inc., runtime: /Users/khmarbaise/.sdkman/candidates/java/7.0.302-zulu/zulu-7.jdk/Contents/Home/jre Default locale: en_GB, platform encoding: UTF-8 OS name: \u0026#34;mac os x\u0026#34;, version: \u0026#34;10.14.6\u0026#34;, arch: \u0026#34;x86_64\u0026#34;, family: \u0026#34;mac\u0026#34; 如果不是用apache版的maven會出現 Maven JDK for importer should be WSL JDK 或 Could not initialize class com.google.inject.internal.cglib.core.$MethodWrapper問題\n安裝sop 去官網下載apache-maven-3.9.6-bin.tar.gz檔 解壓縮tar xzvf apache-maven-3.9.6-bin.tar.gz 可執行mvn --version確認 視情況看是否需要symlink or add 環境變數(PATH) Create a Project mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false\nIntelliJ Project panel doesn\u0026rsquo;t show the folders and files are looking as external 解決SOP:\nclose the project remove it from Recent projects list shut down the IDE delete the .idea folder restart, open the project root folder with File \u0026gt; Open 通用API Logger Java內建的logging套件包含三個元件: Logger/Handler/Formatter 呼叫log()後，\nChap11-Thread Thread 要執行Thread程式，最簡單的方式就是定義一個class繼承Runnable interface，並呼叫start()開始執行:\npackage cc.openhome; public class Hare implements Runnable { private boolean[] flags = {true, false}; private int totalStep; private int step; public Hare(int totalStep) { this.totalStep = totalStep; } @Override public void run() { while(step \u0026lt; totalStep) { var isHareSleep = flags[((int) (Math.random() * 10)) % 2]; if(isHareSleep) { System.out.println(\u0026#34;兔子睡著了zzzz\u0026#34;); } else { step += 2; System.out.printf(\u0026#34;兔子跑了 %d 步...%n\u0026#34;, step); } } } } package cc.openhome; public class TortoiseHareRace2 { public static void main(String[] args) { var tortoise = new Tortoise(10); var hare = new Hare(10); var tortoiseThread = new Thread(tortoise); var hareThread = new Thread(hare); tortoiseThread.start(); hareThread.start(); } } 如果要跑多執行緒，可以將流程定義在Runnable的run()方法，或者繼承Thread類別，並重寫override run()方法。實作Runnable比較有彈性，因為類別還可以繼承其他類別。但若繼承了Thread，那該類別就是一種Thread了。\n// Runnable實例也可以透過Lambda表示來實作，例如: var someThread = new Thread() { public void run() { // implementation } }; // 可以改成 var someThread = new Thread(() -\u0026gt; { //implementation }); synchronized / volatile 每個物件都會有個intrinsic lock (內部鎖，或稱為monitor lock)。被標示為synchronized的區塊會被監控，任何thread要執行synchronized區塊都必須先取得物件的內部鎖。 若在方法前加上synchronized，執行方法必須取得該實例的內部鎖\n基於效率，thread通常會將變數的值cache到自己的記憶體空間中，完成操作再對變數進行更新。問題在快取的時機不一定，若有多個thread存取某個變數，有可能發生變數已經更新，但某些thread還在使用cache值。除了加上synchronized限制存取外，可以在變數上宣告volatile，被標示為volatile的變數，不允許thread快取。\n等待與通知 wait()/notify()/notifyAll()是object定義的方法，用來控制thread釋放物件的內部鎖或通知thead要參加內部鎖的競爭\n執行synchronized的期間，如果呼叫該物件的wait()方法，thread會釋放內部鎖並進入物件的wait set而變成blocked狀態，此時其他thread就可以競爭內部鎖。放在wait set的thread不會參與cpu schedule。wait()可以指定等待時間，時間到thread會再度加入排班；然而若不指定或指定時間為0，thread會持續等待，直到被中斷(interrupt())或通知(notify())可以參加排班\n並行API 使用Thread建立多執行緒程式，必須親自處理synchronized、物件鎖定、wait()/notify()/notifyAll()等細節，如果需要的是thread pool、讀寫鎖等高階操作，可以使用java.util.concurrent套件建立更穩固的併行應用程式\nExecutor Thread的建立與系統資源有關，如何建立thread、是否重複使用thread、何時銷毀thread、runnable何時排定給thread執行都是複雜的議題。因此java定義了java.util.concurrent.Executor的介面，目的在將Runnable的指定與執行分離，executor介面只定義了一個execute()方法\npackage java.util.concurrent public interface Executor { void execute(Runnable command); } Lambda可以當成runnable!\n範例:\n// Pages.java package cc.openhome; import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse.BodyHandlers; import java.util.concurrent.*; import java.io.*; public class Pages { private String[] urls; private String[] fileNames; private Executor executor; public Pages(String[] urls, String[] fileNames, Executor executor) { this.urls = urls; this.fileNames = fileNames; this.executor = executor; } public void download() { for(var i = 0; i \u0026lt; urls.length; i++) { var url = urls[i]; var fileName = fileNames[i]; executor.execute(() -\u0026gt; { try { dump(openStream(url), new FileOutputStream(fileName)); } catch (Exception ex) { throw new RuntimeException(ex); } }); } } private InputStream openStream(String uri) throws Exception { return HttpClient .newHttpClient() .send( HttpRequest.newBuilder(URI.create(uri)).build(), BodyHandlers.ofInputStream() ) .body(); } private void dump(InputStream src, OutputStream dest) throws IOException { try(src; dest) { var data = new byte[1024]; var length = 0; while((length = src.read(data)) != -1) { dest.write(data, 0, length); } } } } 簡單定義一個Executor\n// 這個executor只會逐一下載 package cc.openhome; import java.util.concurrent.Executor; public class DirectExecutor implements Executor { public void execute(Runnable r) { r.run(); } } 定義一個ThreadPerTaskExecutor\n// 這個executor會針對每個網頁啟動一個Thread進行下載 package cc.openhome; import java.util.concurrent.Executor; public class ThreadPerTaskExecutor implements Executor { public void execute(Runnable r) { new Thread(r).start(); } } 也可以搭配threadpool使用\npackage cc.openhome; import java.util.concurrent.Executors; public class Download3 { public static void main(String[] args) { String[] urls = { \u0026#34;https://openhome.cc/Gossip/Encoding/\u0026#34;, \u0026#34;https://openhome.cc/Gossip/Scala/\u0026#34;, \u0026#34;https://openhome.cc/Gossip/JavaScript/\u0026#34;, \u0026#34;https://openhome.cc/Gossip/Python/\u0026#34; }; String[] fileNames = { \u0026#34;Encoding.html\u0026#34;, \u0026#34;Scala.html\u0026#34;, \u0026#34;JavaScript.html\u0026#34;, \u0026#34;Python.html\u0026#34; }; var executorService = Executors.newCachedThreadPool(); new Pages(urls, fileNames, executorService).download(); executorService.shutdown(); } } Java8之後的好用方法 double colon(::)-java8 Method Reference 避免重複撰寫Lambda運算式, 同時能讓程式碼更為清楚 Arrays.sort(names, (name1, name2)-\u0026gt;StringOrder.byLength(name1, name2)); // 可改為 Arrays.sort(names, StringOrder::byLength); of用法-java9 可以簡單看成建立List, Map, Set實例的便捷方法\nList接口，Set接口，Map接口：裡面增加了一個靜態的方法of，可以給集合一次性添加多個元素 static \u0026lt;E\u0026gt; List\u0026lt;E\u0026gt; of (E...elements)\n使用前提： 當集合中存儲的元素個數已經確定了，不再改變時使用。 注意： of方法只適用於List接口，Set接口，Map接口，不適用於接口的實現類 of方法的返回值是一個不能改變的集合，集合不能再使用add,put方法添加元素，會拋出異常 Set接口和Map接口在調用of方法的時候，不能有重覆的元素，否則會拋出異常 lombok vs record vs pojo 參考\n值得注意的是record定義的資料載體可以透過\u0026lt;record\u0026gt;::\u0026lt;attribute\u0026gt;去拿到該record的值\n通常會和of()以及stream()一起使用\npublic class Demo { public static void main(String[] args) { var employees = List.of( new Employee(\u0026#34;Justin\u0026#34;, 39, Gender.MALE), new Employee(\u0026#34;Monica\u0026#34;, 36, Gender.FEMALE), new Employee(\u0026#34;Irene\u0026#34;, 6, Gender.FEMALE) ); var sum = employees.stream() .filter(employee -\u0026gt; employee.gender() == Gender.MALE) .mapToInt(Employee::age) .sum(); var average = employees.stream() .filter(employee -\u0026gt; employee.gender() == Gender.MALE) .mapToInt(Employee::age) .average() .getAsDouble(); var max = employees.stream() .filter(employee -\u0026gt; employee.gender() == Gender.MALE) .mapToInt(Employee::age) .max() .getAsInt(); List.of(sum, average, max).forEach(out::println); } enum Gender { FEMALE, MALE } record Employee(String name, Integer age, Gender gender) {} } text block - java15 String json = \u0026#34;{\\n\u0026#34; + \u0026#34; \\\u0026#34;array\\\u0026#34;: [\\n\u0026#34; + \u0026#34; 1,\\n\u0026#34; + \u0026#34; 2,\\n\u0026#34; + \u0026#34; 3\\n\u0026#34; + \u0026#34; ],\\n\u0026#34; + \u0026#34; \\\u0026#34;boolean\\\u0026#34;: true,\\n\u0026#34; + \u0026#34; \\\u0026#34;color\\\u0026#34;: \\\u0026#34;gold\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;null\\\u0026#34;: null,\\n\u0026#34; + \u0026#34; \\\u0026#34;number\\\u0026#34;: 123,\\n\u0026#34; + \u0026#34; \\\u0026#34;object\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;a\\\u0026#34;: \\\u0026#34;b\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;c\\\u0026#34;: \\\u0026#34;d\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;string\\\u0026#34;: \\\u0026#34;Hello World\\\u0026#34;\\n\u0026#34; + \u0026#34;}\u0026#34;; String json = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;b1oolean\u0026#34;: true, \u0026#34;color\u0026#34;: \u0026#34;gold\u0026#34;, \u0026#34;number\u0026#34;: 123, \u0026#34;string\u0026#34;: \u0026#34;Hello World\u0026#34; } \u0026#34;\u0026#34;\u0026#34;; map vs mapToInt 兩者返回的數據類型不同 map返回Stream object 就只是返回一個通用的stream類型, 可以繼續接map or reduce or filter..等 Stream\u0026lt;T\u0026gt;方法 mapToInt返回IntStream IntStream提供了sum(), average(), max(), min()等方法 Record 參考 大致說來，Kotlin中叫data class，Java中叫Record Class這個名稱不太一樣以外，其它的都是極為類似的。\n我們用Java 17中的Record Class 來重寫上述這個類，代碼是這樣的：\npublic record EmployeeDTO(String name,String idCard,int age){} 是不是幾乎和Kotlin中的data class一模一樣呢?\n是的，就是這麽回事，它簡化了數據類的定義。所以如果你非常厭煩Java數據類的重覆定義，與其去使用lombok這種侵入性非常強的第三方庫，還不如升級使用Java 17。\nrecord class需要關注的點 當然，關於record class，仍然有一些基本原則你需要知道。\n不能在record類的body中添加屬性，屬性只能定義在類的括號後面（稱為header）\npublic record EmployeeDTO(String name,String idCard,int age){ //這是不允許的 private String description; } 可以在record類中添加靜態屬性與方法\npublic record EmployeeDTO(String name,String idCard,int age){ //這是允許的 private static System.Logger logger = System.getLogger(EmployeeDTO.class.getName()); } 可以添加額外的類方法，這是允許的\npublic record EmployeeDTO(String name,String idCard,int age){ //這是允許的 public String toJson(){ //... return \u0026#34;\u0026#34;; } } 比如，你可以添加一個方法，有時候我們需要將數據對象轉換為JSON來傳輸或存儲，那就添加一個toJson方法就好了.\n可以覆蓋默認生成的一些東西\npublic record EmployeeDTO(String name,String idCard,int age){ //這是允許的 public int getAge(){ return age; } } 可以在方法中定義Local Record Classes\n在方法內部，你可以定義一個局部本地的record類\npublic void calculateLocation(double x,double y){ //定義一個本地record類 record Point(double x, double y) {} var point = new Point(x,y); //... } 這個在一些局部方法中需要封裝一些參數時，又沒必要把這個類定義在外面時非常有用。\nJava中的所有record類，都默認實現了Record接口\n@Test void testRecord(){ record Point(double x,double y){} var point = new Point(0,0); //Point是實現了Record接口的 Assertions.assertTrue(point instanceof Record); } Generic Static method 要宣告靜態方法的泛型時, 記得要在static後面加上類別型態\n原因是因為泛型這機制其實是runtime的時候動態的幫你轉換型別\n所以實際上你在宣告(使用)的時候, 會先寫好型別,\n接著在new object的時候就會根據你宣告的型別做轉換\n但問題是靜態方法是在編譯期轉換的, 此時compiler並不知道實際的類別是什麼(不知道怎麼轉換)\n因此才需要在static後面接上型別告訴compiler編譯期要怎麼轉換\n如果想在类的静态方法里上使用泛型, 以及如何在调用的时候, 传入泛型类型呢? 静态方法在 static 关键字之后, 声明泛型: public static \u0026lt;R\u0026gt; Builder\u0026lt;R\u0026gt; builder() {...}\n泛型的來源、原理 Java 會在 編譯期間擦除(type erasure) 所有的泛型訊息，這樣就可以讓 JVM 使用相同的字節碼而不必新增，在 JVM Runtime 時就不存在所謂的泛型訊息 (後面會介紹泛型擦除) 泛型副作用 不能使用基本數據類型 (byte、char、short、int、long、double)，因為擦除後會轉換為 Object 類型 不能使用 instanceof 運算符號，同樣是因為類型擦除後所帶來的副作用，會導致無法判別 擦拭後都是 Object 類型，沒得判斷 不能使用在靜態，泛型創建對象時才能確定，但靜態方法、參數，是不用加載就可以使用 (泛型方法則可以，因為泛型方法是呼叫後才加載) // 假如我们定义一个泛型类Generic class Generic\u0026lt;T\u0026gt; { private T obj; public Generic(T o) { obj = o; } public T getObj() { return obj; } } //那么Java编译后的bytecode中Generic相当于这样的 class Generic { private Object obj; public Generic(Object o) { obj = o; } public Object getObj() { return obj; } } Java - 偽泛型 Java / kotlin 虛擬機其實內部並無泛型，並不是真正的泛型 ，JDK 5 才有泛型，為了向上兼容，才會演變成 ++偽泛型++\n在編譯後的字節碼中以替換成原生類型(Raw Type)，並在相應的第方插入強制轉型代碼，所以對於運行期的 Java 語言來說 List and List 就是同一類別，Java 語言中的泛型實現方法稱為 類型擦除，基於這種方法實現的泛型是偽泛型\n在泛型中並不是所有的擦除都會變成 Object 的，當泛型有限制性，Test，則會被擦除成 Apple\nList list = new ArrayList\u0026lt;Integer\\\u0026gt;(); List\u0026lt;String\u0026gt; list2 = list; 擦除過後 ArrayList 轉為 Array List，List 轉為 List\n參考\n","permalink":"https://kuanyuce.github.io/blog/java17/","tags":["自學筆記","Java"],"title":"Java SE 17"},{"categories":["Go Language"],"contents":"Heading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Emphasis Emphasis, aka italics, with asterisks or underscores.\nStrong emphasis, aka bold, with asterisks or underscores.\nCombined emphasis with asterisks and underscores.\nStrikethrough uses two tildes. Scratch this.\nLink I\u0026rsquo;m an inline-style link\nI\u0026rsquo;m an inline-style link with title\nI\u0026rsquo;m a reference-style link\nI\u0026rsquo;m a relative reference to a repository file\nYou can use numbers for reference-style link definitions\nOr leave it empty and use the link text itself.\nURLs and URLs in angle brackets will automatically get turned into links. http://www.example.com or http://www.example.com and sometimes example.com (but not on Github, for example).\nSome text to show that the reference links can follow later.\nParagraph Lorem ipsum dolor sit amet consectetur adipisicing elit. Quam nihil enim maxime corporis cumque totam aliquid nam sint inventore optio modi neque laborum officiis necessitatibus, facilis placeat pariatur! Voluptatem, sed harum pariatur adipisci voluptates voluptatum cumque, porro sint minima similique magni perferendis fuga! Optio vel ipsum excepturi tempore reiciendis id quidem? Vel in, doloribus debitis nesciunt fugit sequi magnam accusantium modi neque quis, vitae velit, pariatur harum autem a! Velit impedit atque maiores animi possimus asperiores natus repellendus excepturi sint architecto eligendi non, omnis nihil. Facilis, doloremque illum. Fugit optio laborum minus debitis natus illo perspiciatis corporis voluptatum rerum laboriosam.\nList List item List item List item List item List item Unordered List List item List item List item List item List item Code and Syntax Highlighting Inline code has back-ticks around it.\nvar s = \u0026#34;JavaScript syntax highlighting\u0026#34;; alert(s); s = \u0026#34;Python syntax highlighting\u0026#34; print s No language indicated, so no syntax highlighting. But let\u0026#39;s throw in a \u0026lt;b\u0026gt;tag\u0026lt;/b\u0026gt;. Blockquote This is a blockquote example.\nInline HTML You can also use raw HTML in your Markdown, and it\u0026rsquo;ll mostly work pretty well.\nTables Colons can be used to align columns.\nTables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don\u0026rsquo;t need to make the raw Markdown line up prettily. You can also use inline Markdown.\nMarkdown Less Pretty Still renders nicely 1 2 3 Image Youtube video ","permalink":"https://kuanyuce.github.io/blog/post-13/","tags":["Photos","Game","HTML","Python","New"],"title":"How To Use Checklists To Improve Your UX"}]